<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Ken Friis Larsen, Maya Saietz" />
  <title>Exercise Set 1, Haskell</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro|Source+Serif+Pro|Oswald|Source+Code+Pro" />
  <link rel="stylesheet" href="style.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Exercise Set 1, Haskell</h1>
<p class="author"><a href="http://diku.dk/~kflarsen">Ken Friis Larsen</a>, Maya Saietz</p>
<p class="date">September, 2019</p>
</header>
<h2 id="touring-haskell">Touring Haskell</h2>
<ul>
<li><p>Finish the declaration of the function <code>move</code></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Pos</span> <span class="ot">=</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Direction</span> <span class="ot">=</span> <span class="dt">North</span> <span class="op">|</span> <span class="dt">South</span> <span class="op">|</span> <span class="dt">East</span> <span class="op">|</span> <span class="dt">West</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="ot">move ::</span> <span class="dt">Direction</span> <span class="ot">-&gt;</span> <span class="dt">Pos</span> <span class="ot">-&gt;</span> <span class="dt">Pos</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>move <span class="dt">North</span> (x,y) <span class="ot">=</span> (x, y<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>move <span class="dt">West</span>  (x,y) <span class="ot">=</span> (x<span class="op">-</span><span class="dv">1</span>, y)</span></code></pre></div></li>
<li><p>Declare a function <code>moves</code> with the type</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">moves ::</span> [<span class="dt">Direction</span>] <span class="ot">-&gt;</span> <span class="dt">Pos</span> <span class="ot">-&gt;</span> <span class="dt">Pos</span></span></code></pre></div>
<p>The function should return the net result of performing all the moves in sequence.</p></li>
<li><p>Declare functions for adding and multiplying natural numbers, using the following data type declaration:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Nat</span> <span class="ot">=</span> <span class="dt">Zero</span> <span class="op">|</span> <span class="dt">Succ</span> <span class="dt">Nat</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Read</span>, <span class="dt">Ord</span>) </span></code></pre></div>
<p><code>Succ</code> stands for “successor”, and the idea is that <code>Zero</code> represents the natural number 0, <code>Succ Zero</code> represents the natural number 1, <code>Succ (Succ Zero)</code> represents the natural number 2, and so on.</p>
<p>Your functions should work on the above unary representation <em>directly</em>, not by converting to and from native Haskell integers.</p></li>
<li><p>Declare functions <code>nat2int</code> and <code>int2nat</code> to go from natural numbers (the above data type) to Haskell integers and back.</p></li>
<li><p>Here is a data type for representing binary search trees with integers stored in the nodes:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- All leaves in left/right subtree are less/greater than node value</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Tree</span> <span class="ot">=</span> <span class="dt">Leaf</span> <span class="op">|</span> <span class="dt">Node</span> <span class="dt">Int</span> <span class="dt">Tree</span> <span class="dt">Tree</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Read</span>, <span class="dt">Ord</span>)</span></code></pre></div>
<p>Declare a function <code>insert</code> that takes an integer <code>n</code> and a binary search tree <code>t</code>, and returns a new search tree <code>t'</code> with <code>n</code> inserted correctly into <code>t</code>. If <code>n</code> was already present in <code>t</code>, the function should just return <code>t</code> as <code>t'</code>. Insert new elements at the leaves only; do not worry about keeping the tree balanced.</p>
<p><strong>Hint:</strong> You may find the standard function <code>compare</code> useful.</p></li>
<li><p>Adapt the declaration of <code>Tree</code> to <code>PTree</code> (with constructors <code>PLeaf</code> and <code>PNode</code>), so that it is polymorphic in the data stored in the nodes. What happens to the type of the corresponding insertion function <code>pinsert</code>?</p></li>
</ul>
<!--
* Extend the type `Expr` (and the function `value`) with operations for
  multiplication, division, and subtraction 
 
    ~~~~ {.haskell}
    data Expr = Con Int
              | Add Expr Expr
         deriving (Eq, Show, Read, Ord) 

    value :: Expr -> Int
    value (Con n) = n
    value (Add x y) = value x + value y 
    ~~~~
    
    What happens when you divide by 0? What are the maximum and minimum
    numeric values that an `Expr` can evaluate to?

* Write a pretty printer function for `Expr` that inserts as few
  parentheses as you can manage.
-->
<h2 id="morse-code">Morse Code</h2>
<p>[Rephrased from <a href="http://www.rubyquiz.com/quiz121.html">ruby quiz #121</a>]</p>
<p>Morse code is a way to encode telegraphic messages in a series of long and short sounds or visual signals. During transmission, pauses are used to group letters and words, but in written form the code can be ambiguous.</p>
<p>For example, using the typical dot (<code>.</code>) and dash (<code>-</code>) for a written representation of the code, the word <code>...---..-....-</code> in Morse code could be an encoding of the names Sofia or Eugenia depending on where you break up the letters:</p>
<pre><code>  ...|---|..-.|..|.-    Sofia
  .|..-|--.|.|-.|..|.-  Eugenia</code></pre>
<p>We will only focus on the alphabet for this quiz to keep things simple. Here are the encodings for each letter:</p>
<pre><code>  A .-            N -.
  B -...          O ---
  C -.-.          P .--.
  D -..           Q --.-
  E .             R .-.
  F ..-.          S ...
  G --.           T -
  H ....          U ..-
  I ..            V ...-
  J .---          W .--
  K -.-           X -..-
  L .-..          Y -.--
  M --            Z --..</code></pre>
<ul>
<li><p>Declare a function <code>encode</code> that takes a string (of letters) as argument and translate it to Morse code (as a string).</p></li>
<li><p>Declare a function <code>decode</code> that takes a string encoded in morse code as argument and returns a list of all possible translations.</p></li>
</ul>
<h2 id="type-classes">Type classes</h2>
<p>Following is an interface for types whose elements can be said to have a size.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Sizeable</span> t <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  size ::</span> t <span class="ot">-&gt;</span> <span class="dt">Int</span></span></code></pre></div>
<p>We say that elements of a primitive type like <code>Int</code> all have size one:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Sizeable</span> <span class="dt">Int</span> <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  size _ <span class="ot">=</span> <span class="dv">1</span></span></code></pre></div>
<p>When we want to ascribe a size to aggregate types like lists, we need to take a decision: Should the size of a list be just the length of the list, or is the size of a list the sum of the size of the elements plus the length of the list (plus one). Complete the following two instance declarations (one for each interpretation of what sizeable means)</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Sizeable</span> [a] <span class="kw">where</span> </span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Sizeable</span> a <span class="ot">=&gt;</span> <span class="dt">Sizeable</span> [a] <span class="kw">where</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span></code></pre></div>
<p><strong>Note:</strong> You cannot have both instance declarations active at the same time.</p>
<p>Make pairs, <code>String</code>, and <code>Tree</code> sizeable.</p>
<h2 id="tic-tac-toe-advanced">Tic-Tac-Toe (advanced)</h2>
<p>These exercises assume that you have downloaded the file <code>TicTacToe.hs</code>, which you can find on Absalon under <em>Files</em>.</p>
<ul>
<li><p>Define the undefined values <code>startState</code>, <code>makeMove</code>, <code>validMove</code>, <code>allValidMoves</code>, and <code>makeTree</code>.</p>
<p>Define one of them at a time, and make sure that your Haskell file still compiles after each change.</p></li>
<li><p>Make sure that you understand the <code>allNodes</code> function, especially what the functions <code>concatMap</code>, <code>snd</code>, and <code>.</code> (dot) do. Try to write each of these functions yourself.</p></li>
<li><p>Observe the difference in running time of</p>
<pre><code>  length (allNodes (makeTree startState))    -- should return 986410</code></pre>
<p>and</p>
<pre><code>  take 3 (allNodes (makeTree startState))</code></pre>
<p>Can you explain that?</p></li>
<li><p>Watch <a href="http://haskelllive.com/episode-1-the-chess-board/">Haskell Live episode 1</a>, and make <code>showBoard</code> and <code>readBoard</code> functions for tic-tac-toe boards in a similar style as Rein Henrichs (the Haskell Live creator) does for chess boards.</p></li>
<li><p>Implement the <a href="http://en.wikipedia.org/wiki/Minimax">minimax</a> algorithm for finding an optimal move in a given game state.</p></li>
</ul>
<!-- Monads -->
<!-- ------ -->
<!-- * Finish the declaration: -->
<!--     ~~~~ {.haskell} -->
<!--     data List a = Nil | Cons a (List a) -->
<!--     instance Monad List where -->
<!--           ... -->
<!--     ~~~~ -->
<!--     **Hint:** start by thinking about how the normal list is declared as a monad: -->
<!--     ~~~~ {.haskell}       -->
<!--     instance Monad [] where -->
<!--           ... -->
<!--     ~~~~ -->
<!--     **Hint 2:** Start my defining the functions `concat` and `map` for the `List` type and use these in your declarations. -->
<!-- * Rewrite the function `findAssoc` -->
<!--     ~~~~ {.haskell} -->
<!--     type Assoc a = [(String, a)] -->
<!--     findAssoc :: String -> Assoc a -> a -->
<!--     findAssoc key assoc = head bindings -->
<!--         where bindings = [val| (k,val) <- assoc, k == key] -->
<!--     ~~~~ -->
<!--     so that it returns `Nothing` rather than producing an error if no binding is found for a key. -->
<!--     Use the re-written `findAssoc` and the `do`-notation to write a function that takes an association list and two keys as arguments, looks up the keys, add their values, and return the result. -->
</body>
</html>
